#!/usr/bin/env bun
/**
 * {{name}} - PreToolUse Hook
 *
 * This hook runs before tool execution.
 *
 * Exit codes:
 *   0 = allow (continue execution)
 *   1 = error (stop with error)
 *   2 = block (skip this tool call)
 */

interface HookInput {
  /** The tool being called (e.g., "Bash", "Read", "Write") */
  tool_name: string;

  /** Tool input parameters */
  tool_input: Record<string, unknown>;

  /** Optional session ID */
  session_id?: string;

  /** Optional agent type for subagents */
  agent_type?: string;

  /** ISO timestamp of the event */
  timestamp?: string;
}

/**
 * Main hook logic
 */
async function main(): Promise<void> {
  // Read input from stdin
  let rawInput: string;
  try {
    rawInput = await Bun.stdin.text();
  } catch {
    // No input, allow by default
    process.exit(0);
  }

  if (!rawInput.trim()) {
    process.exit(0);
  }

  // Parse JSON input
  let input: HookInput;
  try {
    input = JSON.parse(rawInput) as HookInput;
  } catch {
    // Invalid JSON, allow by default
    process.exit(0);
  }

  // Your hook logic here
  // Example: Only process Bash commands
  if (input.tool_name === 'Bash') {
    const command = (input.tool_input.command as string) || '';

    // Add your checks here
    // Example: Block a specific pattern
    // if (/dangerous-pattern/.test(command)) {
    //   console.error(`[{{name}}] BLOCKED: Dangerous command detected`);
    //   console.error(`[{{name}}] Command: ${command}`);
    //   process.exit(2);
    // }

    console.log(`[{{name}}] Allowed: ${command.slice(0, 50)}...`);
  }

  // Allow by default
  process.exit(0);
}

// Run the hook
main().catch((err) => {
  console.error('[{{name}}] Hook error:', err);
  process.exit(1);
});
